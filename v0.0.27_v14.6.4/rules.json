{
  "content": "<div id=\"rules\">\n<h1 id=\"plinko-xy-rules\">Plinko Seobanda</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>Plinko is the peculiar game of chance played with a ball “plinking” down the vertical board populated with offset rows of pegs, very popular game viewed on TV shows in the 20th century.  BGaming represented the board in the form of a pyramid. The gameplay is simple as it is: the player chooses from 8 to 16 rows, hoping the ball would fall into one of the chosen holes with the best payment, and just watches the “bouncing process through the obstacles” from the top of the pyramid down the board bottom. The ball eventually ends up at the bottom peg and determines the prize. So welcome to the Plinko’s plinkily intricate system, trust your luck and let the ball fall!</p>\n\n<h2 id=\"rules\">Rules</h2>\n\n<p>The goal is to win money by dropping Plinko ball and wait till it lands in the highest money slot at the bottom of the board.</p>\n\n<h2 id=\"betting\">Betting</h2>\n\n<p>Сhoose the bet amount. Buttons <strong>“-”</strong>, <strong>“+”</strong>, <strong>“Min”</strong>, <strong>“Max”</strong> can be used. When the maximum amount is reached, the  buttons <strong>“+”</strong> and <strong>“Max”</strong> become disabled. When the minimum amount is reached, the buttons <strong>“-”</strong> and <strong>“Min”</strong> become disabled. Choose the Risk Level: Low, Normal or High. Choose the number of Lines in the game: from 8 to 16. Choose the Bet Mode: Manual or Auto.</p>\n\n<p>To start the game round press the <strong>Play</strong> button. All betting buttons become inactive at the time of the round except for <strong>Bet Mode</strong>. During the round, another round with the same settings using the <strong>Play</strong> button can be started. At the end of the round, the ball reaches the pocket. On each pocket payout ratio is displayed.</p>\n\n<p>In <strong>Auto Mode</strong>, the field with the number of automatic bets is shown. Choose the <strong>number of bets</strong>. Press <strong>Play</strong> button. The button <strong>Play</strong> is changing to <strong>Stop</strong> with the number of remained bets. A series of rounds can be completed if the number of rounds set  is reached, by clicking on the button <strong>Stop</strong>, if there are not enough funds on the balance.</p>\n\n<h2 id=\"results\">Results</h2>\n\n<p>The calculation of the win is made according to the paytable. The result is added to the balance field. The size of payments varies from low to high.</p>\n\n<div class=\"license-block\">\n\n  <h1 id=\"license-requirements\">License requirements</h1>\n\n  <p>For the Greek license, the maximum allowable bet in the game is <strong>20 EUR</strong>.</p>\n\n  <p>The maximum possible win in the game is <strong>140.000 EUR</strong>.</p>\n</div>\n\n<h2 id=\"return-to-player\">Return to Player</h2>\n\n<p>The overall theoretical Return to Player (RTP) is {RTP.min_rtp}% - {RTP.max_rtp}% depending on the player’s chosen strategy.</p>\n\n<p>Malfunction voids all plays and pays! All unfinished rounds will be terminated every 24 hours. If the game requires “Collect” - “Collect” will take place and the win from the round will be added to the player balance. If the game requires action from a player, the result is counted assuming that the player has chosen the action with no risk without raising the initial bet.</p>\n\n<p>Game Version 1.0.</p>\n<p>The Game Rules as published on this website are in English. Translations into other languages are provided as a service in good faith. In the event of ambiguity between an English version and a translation, the English version always retains priority.</p>\n</div>\n",
  "contentUpdateScript": "const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n",
  "domScripts": [
    "(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp){\n\tconst rtp = options?.math?.rtp ?? null;\n\t\n\tif(!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\t\n\treturn Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n\t\tif (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n\t\t\tresult[rtpName] = rtpValue;\n\t\t}\n\t\treturn result;\n\t}, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp){\t\n\tdocument.querySelectorAll('[class*=\"rtp\"]').forEach(fragment => {\n\t\tconst rtpName = fragment.className.replace('rtp-', '');\n\t\tconst isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n\t\tconst isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\t\t\n\t\tif(isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp){\n\t\t\tfragment.parentElement.removeChild(fragment);\n\t\t}\n\t});\n}\n\nfunction replaceContent() {\n\tconst casinoOptions = window.__OPTIONS__;\n\t\n\tconst rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n\tconst isNeedRemovePurchasesRtp = (rulesLicense === 'greek');\n\n\tconst rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n\tremoveBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n}\n\nreplaceContent();\n\n})()\n"
  ]
}
